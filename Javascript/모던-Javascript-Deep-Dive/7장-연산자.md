# 7장 연산자

- 하나 이상의 표현식을 대상으로 연산을 수행해서 하나의 값을 만듦
- 피연산자: 연산의 대상

```javascript
5 * 4;

// 연산자: *
// 피연산자: 5, 4
```

- 피연산자는 값으로 평가할 수 있어야 한다.

## 7.1 산술 연산자

- 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자를 만든다.
- 산술 연산이 불가능한 경우 `NaN`을 반환

### 7.1.1 이항 산술 연산자

| 이항 산술 연산자 |  의미  | 피연산자가 변경되는가? |
| :--------------: | :----: | :--------------------: |
|        +         |  덧셈  |           X            |
|        -         |  뺄셈  |           X            |
|        \*        |  곱셈  |           X            |
|        /         | 나눗셈 |           X            |
|        %         | 나머지 |           X            |

### 7.1.2 단항 산술 연산자

| 단항 산술 연산자 |        의미         | 피연산자가 변경되는가? |
| :--------------: | :-----------------: | :--------------------: |
|        ++        |        증가         |           O            |
|        --        |        감소         |           O            |
|        +         | 숫자 타입으로 변환  |           X            |
|        -         | 음 <-> 양 부호 반전 |           X            |

```javascript
let x = 10;

// 전위 연산자
// 10, 11. 실행을 먼저 하고 값을 증/감
console.log(x++);
console.log(x--);

// 후위 연산자
// 10, 9. 증/감을 먼저 하고 실행
console.log(++x);
console.log(--x);
```

- 전위, 후위 연산자의 특징을 잘 파악하고 사용하자!

```javascript
let x = "1";

// 1
console.log(+x);
```

- 숫자 타입이 아닌 피연산자를 숫자 타입으로 반환
- 피연산자를 변경하는 건 아니고, 변환된 값을 반환한다.
- `-` 단항 연산자도 숫자 타입이 아닌 피연산자에 사용하면 숫자 타입으로 변환된다. + 부호 변환

## 7.1.3 문자열 연결 연산자

```javascript
// string + number = string
"1" + 2; // '12'
1 + "2"; // '12'

// 숫자끼리는 + 연산
1 + 2; // 3

// 암묵적 타입 변환 implicit coercion
// 타입 강제 변환 type coercion
// true는 1, false는 0으로 변환된다.
1 + true; // 2
1 + false; // 1

// null도 0
1 +
  null + // 1
  // undefined는 변환되지 않는다.
  undefined; // NaN
1 + undefined; // NaN
```

## 7.2 할당 연산자

| 할당 연산자 |    예    |  동일 표현  | 피연산자가 변경되는가? |
| :---------: | :------: | :---------: | :--------------------: |
|      =      | `x = 5`  |   `x = 5`   |           O            |
|     +=      | `x += 5` | `x = x + 5` |           O            |
|     -=      | `x -= 5` | `x = x - 5` |           O            |
|     \*=     | `x *= 5` | `x = x * 5` |           O            |
|     /=      | `x /= 5` | `x = x / 5` |           O            |
|     %=      | `x %= 5` | `x = x % 5` |           O            |

- 할당문은 값으로 평가되는 표현식이다.
- 할당된 값으로 평가된다.

```javascript
a = b = c = 0;
```

- 이러한 특성을 살려 변수에 동일한 값을 연쇄 할당할 수 있다.

## 7.3 비교 연산자

### 7.3.1 동등/일치 비교 연산자

| 비교 연산자 |    의미     |   사례    |            뜻            | 피연산자가 변경되는가? |
| :---------: | :---------: | :-------: | :----------------------: | :--------------------: |
|     ==      |  동등 비교  | `x == y`  |    x와 y의 값이 같음     |           X            |
|     ===     |  일치 비교  | `x === y` | x와 y의 값과 타입이 같음 |           X            |
|     !=      | 부동등 비교 | `x != y`  |    x와 y의 값이 다름     |           X            |
|     !==     | 불일치 비교 | `x !== y` | x와 y의 값과 타입이 다름 |           X            |

```javascript
5 == 5; // true
5 == "5"; // true

5 === 5; // true
5 !== "5"; // false
```

- 동등 비교 연산자는 암묵적인 타입 변환이 일어나므로 개발자의 예상과 다른 결과를 낼 수 있음.
- 되도록이면 `===` 연산자를 사용하도록 하자!

```javascript
NaN === NaN; // false

Number.isNaN(NaN); // true
```

- `NaN`인지 알아볼 때는 `===` 대신 `Number.isNaN()`을 사용한다.

```javascript
0 === -0; // true
Object.is(-0, +0); // false
```

- 플러스 0과 마이너스 0은 다른 값인데, `===`을 사용하면 같다고 나오므로 주의!

### 7.3.2 대소 관계 비교 연산자

| 대소 관계 비교 연산자 |   예제   |         설명          | 피연산자가 변경되는가? |
| :-------------------: | :------: | :-------------------: | :--------------------: |
|           >           | `x > y`  |    x가 y보다 크다     |           X            |
|           <           | `x < y`  |    x가 y보다 작다     |           X            |
|          >=           | `x >= y` | x가 y보다 크거나 같다 |           X            |
|          <=           | `x <= y` | x가 y보다 작거나 같다 |           X            |

## 7.4 삼항 조건 연산자

```javascript
let x = 2;

// 2 % 2 = 0 = false
let result = x % 2 ? "홀수" : "짝수";
// x % 2에서 나머지가 있으면(true) 홀수, 없으면(false) 짝수라는 문자열이 할당된다.

// 삼항 연산자는 다음의 if~else문과 동일한 의미를 가진다.
if (x % 2) result = "홀수";
else result = "짝수";
```

- 삼항 연산자는 `if~else`문과 동일한 의미를 가진다.
- 그러나 삼항 연산자는 값으로 평가할 수 있는 표현식이다.
- `if~else`는 값으로 사용할 수 없는 문이다.
  - 그렇구나! 그래서 `jsx` 안에 삼항 연산자는 쓸 수 있는데 `if~else`는 안 되는 거였다.

## 7.5 논리 연산자

| 논리 연산자 |    의미     | 피연산자가 변경되는가? |
| :---------: | :---------: | :--------------------: |
|   `\|\|`    | 논리합(OR)  |           X            |
|    `&&`     | 논리곱(AND) |           X            |
|     `!`     |  부정(NOT)  |           X            |

- 논리 부정(`!`) 연산자에서, 피연산자가 불리언이 아니면 불리언으로 암묵적 타입 변환된다.

```javascript
!0; // true
!"Hello"; // false
```

- 논리합(`||`), 논리곱(`&&`) 표현식의 평가 결과는 불리언 값이 아닐 수도 있다.

```javascript
`Cat` && `Dog`; // `Dog`
```

- 와.. 당연히 `true && true`로 `true`일 줄 알았는데...
  - `true && 'Dog'`으로 평가된 건가?

### 드모르간의 법칙

```javascript
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

- 복잡한 논리식은 드모르간 법칙을 사용해서 간단하게 나타낼 수 있어!

## 7.6 쉼표 연산자

```javascript
let x, y, z;

(x = 1), (y = 2), (z = 3);
```

- 왼쪽 피연산자부터 차례대로 평가하고, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평과 결과를 반환한다.

## 7.7 그룹 연산자

```javascript
10 * 2 + 3; //23

10 * (2 + 3); //50
```

- 소괄호(`()`)를 사용하여 연산자의 우선순위를 조절할 수 있다.

## 7.8 `typeof` 연산자

```javascript
typeof ""; // string
typeof 1; // number
typeof NaN; // number
typeof true; // boolean
typeof undefined; // undefined
typeof Symbol(); // symbol
typeof null; // object
typeof []; // object
typeof {}; // object
typeof new Date(); // object
typeof /test/gi; // object
typeof function () {}; // function
```

- typeof로 `null`을 검사하면 `object` 형이 나온다.
  - 버그지만 기존 코드에 영향을 줄까봐 수정되지 못하고 있다고 함
  - null을 확인할 때는 typeof 대신 `===`를 사용하자.

```javascript
typeof undeclared; // undefined
```

- 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 `ReferenceError` 대신 `undefined`를 반환한다.
