# 12장 함수

## 12.1 함수란?

- 함수(function): 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 매개변수(parameter): 함수 내부로 입력을 전달받는 변수
- 인수(argument): 입력
- 반환값(return value): 출력
- 함수는 값이며, 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.

```javascript
// 함수 정의
function add(x, y) {
  return x + y; // 함수 반환값
}

// 함수 호출 (2, 3은 각각 인수다.)
add(2, 3);
```

## 12.2 함수를 사용하는 이유

- 코드의 재사용: 같은 코드를 중복해서 몇 번이고 작성하는 게 아니라, 함수로 만들어서 몇 번이든 호출할 수 있다.
- 유지보수의 편의성, 코드의 신뢰성: 중복되는 코드를 억제하고, 수정 시 실수를 줄인다.
- 코드의 가독성: 함수에 식별자를 붙여 함수 내부의 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 돕는다.
  > 코드는 동작하는 것만이 아닌, 개발자를 위한 문서이다. 사람이 읽을 때의 가독성도 고려하도록 하자!

## 12.3 함수 리터럴

```javascript
var f = function add(x, y) {
  return x + y;
};
```

- 함수는 객체이다. = **변수에 할당할 수 있다!**
- 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.

## 12.4 함수 정의

- 함수를 정의하는 방법 4가지

1. 함수 선언문
   ```javascript
   function add(x, y) {
     return x + y;
   }
   ```
2. 함수 표현식
   ```javascript
   var add = function (x, y) {
     return x + y;
   };
   ```
3. `Function` 생성자 함수
   ```javascript
   var add = new Function("x", "y", "return x + y");
   ```
4. 화살표 함수(ES6)
   ```javascript
   var add = (x, y) => x + y;
   ```

- 변수 선언과 함수 정의
  - 변수는 선언(declaration)하고, 함수는 정의(definition)한다.
  - 변수는 처음에는 `undefined`, 정의되지 않았다가 선언문을 해석하면서 비로소 값이 할당된다.
  - 함수는 객체이므로, 변수에 할당하면 `변수에 특정한 값을 정의`하게 된다.

### 12.4.1 함수 선언문

```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조
// console.dir = 함수 객체의 프로퍼티까지 출력, Node.js 환경에서는 console.log과 같은 결과
console.dir(add); // f add(x, y)
console.log(add(2, 5)); // 7
```

- 함수 선언문은 함수 리터럴과 달리 함수 이름을 생략할 수 없다.
- 표현식 X 문 O: 개발자 도구 콘솔에서 함수 선언문을 실행하면 `undefined`가 출력된다.
  - 표현식이라면 `undefined` 대신 평가된 값이 콘솔에 출력되겠지?
  - ?? 변수에 할당 되던데?

```javascript
// 선언문이 왜 변수에 할당될까?
var add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5));
```

- 자바스크립트 엔진은 코드의 문맥에 따라 유연하게 해석한다.
  - 단독으로 사용하면 함수 선언문으로, 피연산자로 사용하면 함수 리터럴로 해석한다.
  - 단, 함수 선언문이 함수 리터럴로 해석될 때는 함수 이름으로 외부에서 호출할 수는 없다.
- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

### 12.4.2 함수 표현식

- 일급 객체: 값의 성질을 갖는 객체
  - 값처럼 변수에 할당할 수 있고 프로퍼티 값도 될 수 있고 배열의 요소도 될 수 있으니 자바스크립트의 함수는 일급 객체다!
- 함수 표현식(function expression): 함수 리터럴로 생성한 객체를 변수에 할당한 것

```javascript
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

- 함수 표현식에서는 함수 리터럴의 이름을 생략하는 것이 일반적이다. (익명 함수)
- 함수 이름을 정의할 경우(기명 함수) 함수 외부에서는 접근할 수 없다.

```javascript
var add = function foo(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
console.loog(foo(2, 5)); // ReferenceError: foo is not defined
```

### 12.4.3 함수 생성 시점과 함수 호이스팅

- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수는 생성 시점이 다르다.

```javascript
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
```

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있지만, 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
- 함수 호이스팅(function hoisting): 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 변수 호이스팅: `var`로 선언된 변수는 런타임 이전에 자바스크립트 엔진이 먼저 실행하여 식별자를 생성하고, `undefined`로 초기화된다. 이후 할당문을 만나면 해당 값으로 초기화된다.
- 함수 표현식은 **변수에 값(함수 표현식)을 할당**하는 것이므로, 함수 호이스팅 대신 변수 호이스팅이 발생한다. `undefined`였다가 함수 표현식을 만나면 그 때 평가되어 함수 객체가 된다!
- 그런데... 함수를 선언하기 전에 실행한다는 게 말이 돼? 되도록이면 함수 표현식을 사용하도록 하자.

### 12.4.4 `Function` 생성자 함수

- `Function` 생성자를 `new`와 함께 호출하여 함수를 만들 수 있다.

```javascript
var add = new Function("x", "y", "return x + y");
console.log(add(2, 5)); // 7
```

- `Function` 생성자 함수로 함수를 생성하면 **함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.** (클로저 생성 X 등...)
- 일반적이지 않고, 바람직하지 않은 방법. 다른 방법을 쓰도록 하자.

### 12.4.5 화살표 함수 Arrow Function

- `function` 키워드 대신 화살표 `=>`를 사용하여 함수를 선언할 수 있다.
- 항상 익명 함수로 정의한다.

```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

- 기존 함수보다 내부 동작이 간략화되어 있다.
  - `this` 바인딩 방식이 다름
  - `prototype` 프로퍼티 X
  - `arguments` 객체 생성 X
