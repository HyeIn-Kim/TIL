# 11장 원시 값과 객체의 비교

| 원시 타입                                                            | 객체 타입                                                                       |
| -------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| 변경 불가능한 값(immutable value)                                    | 변경 가능한 값(mutable value)                                                   |
| 변수에 할당하면 변수에는 실제 값이 저장됨                            | 변수에 할당하면 참조 값이 저장됨                                                |
| 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달됨: pass by value | 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됨: pass by reference |

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 변경 불가능한 값 immutable value (Read Only)
  - 변수 재할당을 통해 값이 변경되는 것처럼 보이는 거지, 값 자체를 변경할 수는 없다.
  - 상수(`const`)는 재할당이 금지된 변수

### 11.1.2 문자열과 불변성

- 자바스크립트에서의 `String`은 원시 타입인 문자열 타입 (객체 X)
- 유사 배열 객체(array-like object), 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있음

```javascript
var str = "string";

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시 값이므로 변경할 수 없다. 에러 발생 X
str[0] = "S";
console.log(str);
```

### 11.1.3 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다.

```javascript
var score = 80;
var copy = score; // score: 80, copy: 80

score = 100; // score: 100, copy: 80
```

- `score`와 `copy`는 다른 메모리 공간에 저장된 별개의 값이다.
- 둘 중 하나의 값을 변경해도 상대의 값에 영향을 주지 않음!

## 11.2 객체

- 자바스크립트의 객체는 프로퍼티를 동적으로 추가/삭제할 수 있다.
- 해시 테이블과 유사하지만 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다.

### 11.2.1 변경 가능한 값

- 원시 값과는 달리, 객체는 변경 가능한 값(mutable value)이다.
  - 원시 값 변수 -> 값의 메모리 주소 -> 값 접근
  - 객체 변수 -> 객체가 있는 메모리 주소 -> 참조 값 접근
- 객체는 mutable하므로 재할당 없이 객체를 직접 변경하거나 프로퍼티를 동적으로 추가하는 일도 가능하다.
- 여러 개의 식별자가 하나의 변수를 공유할 수 있다.

### 얕은 복사와 깊은 복사

- 객체의 경우
  - 얕은 복사(shallow copy): 한 단계까지만 복사
  - 깊은 복사(deep copy): 객체에 중첩되어 있는 객체까지 모두 복사

```javascript
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o };
console.log(c1 === o);
console.log(c1.x === o.x);

// lodash의 cloneDeep을 사용한 깊은 복사
// npm install lodash로 lodash를 설치한 후, Node.js 환경에서 실행한다.
const _ = require("lodash");
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o);
console.log(c2.x === o.x);
```

- 여기까지 읽고 현재 진행중인 프로젝트에서 깊은 복사인 줄 알았는데 얕은 복사를 했었어서 리팩토링한 예시 - [State Immutability 지키기](../../Redux/state의-Immutability-유지하기.md)
- 얕은 복사, 깊은 복사 하는 방법 정리 - [얕은 복사와 깊은 복사](../%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC.md)

### 11.2.2 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.
  - 여러 개의 식별자가 하나의 객체를 공유할 수 있음
- 왜 이런 일이 일어나는 것일까?
  - 원시 값은 변수에 값이 저장되어 있고 객체는 참조 값이 저장된다.
  - 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 전달한다면...?
  - 방식은 같은데, 저장되어 있는 값이 달라서 둘의 차이가 발생하는 거였다.
